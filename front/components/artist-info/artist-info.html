<link rel="import" href="../standard/paper-radio-group/paper-radio-group.html">
<link rel="import" href="../standard/paper-radio-button/paper-radio-button.html">
<link rel="import" href="../standard/core-collapse/core-collapse.html">
<link rel="import" href="../standard/core-ajax/core-ajax.html">
<link rel="import" href="../standard/paper-toast/paper-toast.html">

<polymer-element name="artist-info">
   <template>
      <link rel="stylesheet" type="text/css" href="artist-info.css">
      <h2 on-click="{{ toggleCollapse }}">{{ artist }}</h2>
      <core-collapse id="collapse">
         <div id="wrapper">
            <div id="chart" flex>
               <content></content>
            </div>
            <div class="legend">
               <paper-radio-group id="albums" multi="true" toggle layout horizontal>
                  <template repeat="{{ a, i in albums }}">
                     <paper-radio-button flex class="{{ i | albumColor }}"
                        name="{{ a }}" label="{{ a }}" toggles></paper-radio-button>
                  </template>
               </paper-radio-group>
            </div>
         </div>
      </core-collapse>
      <core-ajax id="ajax"
         url="http://localhost:5000/counts?user={{ user }}&artist={{ artist | escape }}"
         handleAs="json"
         on-core-response="{{ loadChart }}"
      ></core-ajax>
      <paper-toast id="toast" text="error"></paper-toast>
   </template>
      <script>

Polymer('artist-info', {
   publish: {
      artist: '',
      user: ''
   },

   observe: {
      '$.albums.selected': 'updateAlbums'
   },

   created: function() {
      this.lastChart = null;
      this.albums = [];
   },

   toggleCollapse: function() {
      this.$.collapse.toggle();
      if (this.$.collapse.opened && !this.lastChart) {
         //this.loadChart();
         this.$.ajax.go();
      }
   },

   domReady: function() {
      // Select all albums initially.
      this.toggleCollapse();
   },

   loadChart: function(evt) {
      // Try to parse response.
      var histograms;
      try {
         histograms = evt.detail.response.histograms;
      } catch(err) {
         this.$.toast.show();
      }

      var domain = this.getDomain(histograms);

      console.log(histograms);
      var chartData = [];
      var i = 0;
      this.albums = [];
      for (album in histograms) {
         chartData.push({
            key: album,
            values: this.toChartPoints(histograms[album], i, domain),
            color: this.albumColorCode(i++)
         });
         this.albums.push(album);
      }
      this.$.albums.selected = this.albums.map(function (val) { return val });
      var container = this.querySelector('.chart_svg');
      var chartChanger = this.updateChart.bind(this);
      nv.addGraph({
         generate: function() {
            var chart = this.formattedChart();
            chart.xDomain(Object.keys(domain).sort());
            var svg = d3.select(container).datum(chartData);
            svg.transition().duration(0).call(chart);
            this.lastChart = chart;
            return chart;
         }.bind(this)
      });
   },

   toChartPoints: function(histogram, series, domain) {
      var result = [];
      var i = 0;
      var seen = {};
      for (date in histogram) {
         var pt = {
            series: series,
            x: parseInt(date),
            y: histogram[date],
         };
         seen[date] = true;
         result.push(pt);
      }
      for (date in domain) {
         if (!(date in seen)) {
            result.push({
               series: series,
               x: domain[date],
               y: 0
            });
         }
      }
      result.sort(function(a, b) { return a.x - b.x; })
      return result;
   },

   getDomain: function(histograms) {
      var domain = {};
      for (album in histograms)
         for (date in histograms[album])
            domain[date] = parseInt(date);
      return domain;
   },

   formattedChart: function() {
      var chart = nv.models.multiBarChart();
      chart.options({
         showControls: false,
         tooltips: false,
         showXAxis: true,
         showYAxis: true,
         showLegend: false,
         stacked: true
      });
      chart.xAxis.axisLabel('Date Played').tickFormat(
         function(d) { return /*d3.time.format('%b. %d')(new Date(d)) + ' ' + */ d; }
      );
      chart.yAxis.axisLabel('Play Count').tickFormat(d3.format('d'));
      return chart;
   },

   albumColor: function(i) {
      return window.GET_COLOR(i);
   },

   albumColorCode: function(i) {
      return window.COLOR_CODES[GET_COLOR(i)];
   },

   escape: function(str) {
      return escape(str);
   },

   updateChart: function(disabled) {
      if(this.lastChart) {
         if (disabled)
            this.lastChart.dispatch.changeState({'disabled': disabled});
         this.lastChart.update();
      }
   },

   updateAlbums: function() {
      var selected = this.$.albums.selected;
      if (selected && this.albums) {
         var disabled = this.albums.map(function(a) {
            return selected.indexOf(a) == -1;
         });
         console.log('s: ' + selected);
         console.log('d: ' + disabled);
         this.updateChart(disabled);
      }
   }
});

   </script>
</polymer-element>
